// Hint files help the Visual Studio IDE interpret Visual C++ identifiers
// such as names of functions and macros.
// For more information see https://go.microsoft.com/fwlink/?linkid=865984
#define GDCLASS(m_class, m_inherits) private: void operator=(const m_class &p_rval) {} friend class ::godot::ClassDB; protected: virtual const ::godot::StringName *_get_extension_class_name() const override { static ::godot::StringName string_name = get_class_static(); return &string_name; } virtual const GDExtensionInstanceBindingCallbacks *_get_bindings_callbacks() const override { return &_gde_binding_callbacks; } static void (*_get_bind_methods())() { return &m_class::_bind_methods; } static void (::godot::Wrapped::*_get_notification())(int) { return (void(::godot::Wrapped::*)(int)) & m_class::_notification; } static bool (::godot::Wrapped::*_get_set())(const ::godot::StringName &p_name, const ::godot::Variant &p_property) { return (bool(::godot::Wrapped::*)(const ::godot::StringName &p_name, const ::godot::Variant &p_property)) & m_class::_set; } static bool (::godot::Wrapped::*_get_get())(const ::godot::StringName &p_name, ::godot::Variant &r_ret) const { return (bool(::godot::Wrapped::*)(const ::godot::StringName &p_name, ::godot::Variant &r_ret) const) & m_class::_get; } static void (::godot::Wrapped::*_get_get_property_list())(::godot::List<::godot::PropertyInfo> * p_list) const { return (void(::godot::Wrapped::*)(::godot::List<::godot::PropertyInfo> * p_list) const) & m_class::_get_property_list; } static bool (::godot::Wrapped::*_get_property_can_revert())(const ::godot::StringName &p_name) { return (bool(::godot::Wrapped::*)(const ::godot::StringName &p_name)) & m_class::_property_can_revert; } static bool (::godot::Wrapped::*_get_property_get_revert())(const ::godot::StringName &p_name, ::godot::Variant &) { return (bool(::godot::Wrapped::*)(const ::godot::StringName &p_name, ::godot::Variant &)) & m_class::_property_get_revert; } static ::godot::String (::godot::Wrapped::*_get_to_string())() { return (::godot::String(::godot::Wrapped::*)()) & m_class::_to_string; } template <class T, class B> static void register_virtuals() { m_inherits::register_virtuals<T, B>(); } public: static void initialize_class() { static bool initialized = false; if (initialized) { return; } m_inherits::initialize_class(); if (m_class::_get_bind_methods() != m_inherits::_get_bind_methods()) { _bind_methods(); m_inherits::register_virtuals<m_class, m_inherits>(); } initialized = true; } static ::godot::StringName &get_class_static() { static ::godot::StringName string_name = ::godot::StringName(#m_class); return string_name; } static ::godot::StringName &get_parent_class_static() { return m_inherits::get_class_static(); } static GDExtensionObjectPtr create(void *data) { m_class *new_object = memnew(m_class); return new_object->_owner; } static void notification_bind(GDExtensionClassInstancePtr p_instance, int32_t p_what) { if (p_instance && m_class::_get_notification()) { if (m_class::_get_notification() != m_inherits::_get_notification()) { m_class *cls = reinterpret_cast<m_class *>(p_instance); return cls->_notification(p_what); } m_inherits::notification_bind(p_instance, p_what); } } static GDExtensionBool set_bind(GDExtensionClassInstancePtr p_instance, GDExtensionConstStringNamePtr p_name, GDExtensionConstVariantPtr p_value) { if (p_instance && m_class::_get_set()) { if (m_class::_get_set() != m_inherits::_get_set()) { m_class *cls = reinterpret_cast<m_class *>(p_instance); return cls->_set(*reinterpret_cast<const ::godot::StringName *>(p_name), *reinterpret_cast<const ::godot::Variant *>(p_value)); } return m_inherits::set_bind(p_instance, p_name, p_value); } return false; } static GDExtensionBool get_bind(GDExtensionClassInstancePtr p_instance, GDExtensionConstStringNamePtr p_name, GDExtensionVariantPtr r_ret) { if (p_instance && m_class::_get_get()) { if (m_class::_get_get() != m_inherits::_get_get()) { m_class *cls = reinterpret_cast<m_class *>(p_instance); return cls->_get(*reinterpret_cast<const ::godot::StringName *>(p_name), *reinterpret_cast<::godot::Variant *>(r_ret)); } return m_inherits::get_bind(p_instance, p_name, r_ret); } return false; } static const GDExtensionPropertyInfo *get_property_list_bind(GDExtensionClassInstancePtr p_instance, uint32_t *r_count) { if (p_instance && m_class::_get_get_property_list()) { if (m_class::_get_get_property_list() != m_inherits::_get_get_property_list()) { m_class *cls = reinterpret_cast<m_class *>(p_instance); ERR_FAIL_COND_V_MSG(!cls->plist_owned.is_empty() || cls->plist != nullptr || cls->plist_size != 0, nullptr, "Internal error, property list was not freed by engine!"); cls->_get_property_list(&cls->plist_owned); cls->plist = reinterpret_cast<GDExtensionPropertyInfo *>(memalloc(sizeof(GDExtensionPropertyInfo) * cls->plist_owned.size())); cls->plist_size = 0; for (const ::godot::PropertyInfo &E : cls->plist_owned) { cls->plist[cls->plist_size].type = static_cast<GDExtensionVariantType>(E.type); cls->plist[cls->plist_size].name = E.name._native_ptr(); cls->plist[cls->plist_size].hint = E.hint; cls->plist[cls->plist_size].hint_string = E.hint_string._native_ptr(); cls->plist[cls->plist_size].class_name = E.class_name._native_ptr(); cls->plist[cls->plist_size].usage = E.usage; cls->plist_size++; } if (r_count) *r_count = cls->plist_size; return cls->plist; } return m_inherits::get_property_list_bind(p_instance, r_count); } return nullptr; } static void free_property_list_bind(GDExtensionClassInstancePtr p_instance, const GDExtensionPropertyInfo *p_list) { if (p_instance) { m_class *cls = reinterpret_cast<m_class *>(p_instance); ERR_FAIL_COND_MSG(cls->plist == nullptr, "Internal error, property list double free!"); memfree(cls->plist); cls->plist = nullptr; cls->plist_size = 0; cls->plist_owned.clear(); } } static GDExtensionBool property_can_revert_bind(GDExtensionClassInstancePtr p_instance, GDExtensionConstStringNamePtr p_name) { if (p_instance && m_class::_get_property_can_revert()) { if (m_class::_get_property_can_revert() != m_inherits::_get_property_can_revert()) { m_class *cls = reinterpret_cast<m_class *>(p_instance); return cls->_property_can_revert(*reinterpret_cast<const ::godot::StringName *>(p_name)); } return m_inherits::property_can_revert_bind(p_instance, p_name); } return false; } static GDExtensionBool property_get_revert_bind(GDExtensionClassInstancePtr p_instance, GDExtensionConstStringNamePtr p_name, GDExtensionVariantPtr r_ret) { if (p_instance && m_class::_get_property_get_revert()) { if (m_class::_get_property_get_revert() != m_inherits::_get_property_get_revert()) { m_class *cls = reinterpret_cast<m_class *>(p_instance); return cls->_property_get_revert(*reinterpret_cast<const ::godot::StringName *>(p_name), *reinterpret_cast<::godot::Variant *>(r_ret)); } return m_inherits::property_get_revert_bind(p_instance, p_name, r_ret); } return false; } static void to_string_bind(GDExtensionClassInstancePtr p_instance, GDExtensionBool *r_is_valid, GDExtensionStringPtr r_out) { if (p_instance && m_class::_get_to_string()) { if (m_class::_get_to_string() != m_inherits::_get_to_string()) { m_class *cls = reinterpret_cast<m_class *>(p_instance); *reinterpret_cast<::godot::String *>(r_out) = cls->_to_string(); *r_is_valid = true; return; } m_inherits::to_string_bind(p_instance, r_is_valid, r_out); } } static void free(void *data, GDExtensionClassInstancePtr ptr) { if (ptr) { m_class *cls = reinterpret_cast<m_class *>(ptr); cls->~m_class(); ::godot::Memory::free_static(cls); } } static void *_gde_binding_create_callback(void *p_token, void *p_instance) { return nullptr; } static void _gde_binding_free_callback(void *p_token, void *p_instance, void *p_binding) { } static GDExtensionBool _gde_binding_reference_callback(void *p_token, void *p_instance, GDExtensionBool p_reference) { return true; } static constexpr GDExtensionInstanceBindingCallbacks _gde_binding_callbacks = { _gde_binding_create_callback, _gde_binding_free_callback, _gde_binding_reference_callback, };
#define GDCLASS(m_class, m_inherits) private: void operator=(const m_class &p_rval) {} friend class ::ClassDB; public: static constexpr bool _class_is_enabled = !bool(GD_IS_DEFINED(ClassDB_Disable_##m_class)) && m_inherits::_class_is_enabled; virtual String get_class() const override { if (_get_extension()) { return _get_extension()->class_name.operator String(); } return String(#m_class); } virtual const StringName *_get_class_namev() const override { static StringName _class_name_static; if (unlikely(!_class_name_static)) { StringName::assign_static_unique_class_name(&_class_name_static, #m_class); } return &_class_name_static; } static _FORCE_INLINE_ void *get_class_ptr_static() { static int ptr; return &ptr; } static _FORCE_INLINE_ String get_class_static() { return String(#m_class); } static _FORCE_INLINE_ String get_parent_class_static() { return m_inherits::get_class_static(); } static void get_inheritance_list_static(List<String> *p_inheritance_list) { m_inherits::get_inheritance_list_static(p_inheritance_list); p_inheritance_list->push_back(String(#m_class)); } virtual bool is_class(const String &p_class) const override { if (_get_extension() && _get_extension()->is_class(p_class)) { return true; } return (p_class == (#m_class)) ? true : m_inherits::is_class(p_class); } virtual bool is_class_ptr(void *p_ptr) const override { return (p_ptr == get_class_ptr_static()) ? true : m_inherits::is_class_ptr(p_ptr); } static void get_valid_parents_static(List<String> *p_parents) { if (m_class::_get_valid_parents_static != m_inherits::_get_valid_parents_static) { m_class::_get_valid_parents_static(p_parents); } m_inherits::get_valid_parents_static(p_parents); } protected: _FORCE_INLINE_ static void (*_get_bind_methods())() { return &m_class::_bind_methods; } public: static void initialize_class() { static bool initialized = false; if (initialized) { return; } m_inherits::initialize_class(); ::ClassDB::_add_class<m_class>(); if (m_class::_get_bind_methods() != m_inherits::_get_bind_methods()) { _bind_methods(); } initialized = true; } protected: virtual void _initialize_classv() override { initialize_class(); } _FORCE_INLINE_ bool (Object::*_get_get() const)(const StringName &p_name, Variant &) const { return (bool(Object::*)(const StringName &, Variant &) const) & m_class::_get; } virtual bool _getv(const StringName &p_name, Variant &r_ret) const override { if (m_class::_get_get() != m_inherits::_get_get()) { if (_get(p_name, r_ret)) { return true; } } return m_inherits::_getv(p_name, r_ret); } _FORCE_INLINE_ bool (Object::*_get_set() const)(const StringName &p_name, const Variant &p_property) { return (bool(Object::*)(const StringName &, const Variant &)) & m_class::_set; } virtual bool _setv(const StringName &p_name, const Variant &p_property) override { if (m_inherits::_setv(p_name, p_property)) { return true; } if (m_class::_get_set() != m_inherits::_get_set()) { return _set(p_name, p_property); } return false; } _FORCE_INLINE_ void (Object::*_get_get_property_list() const)(List<PropertyInfo> * p_list) const { return (void(Object::*)(List<PropertyInfo> *) const) & m_class::_get_property_list; } virtual void _get_property_listv(List<PropertyInfo> *p_list, bool p_reversed) const override { if (!p_reversed) { m_inherits::_get_property_listv(p_list, p_reversed); } p_list->push_back(PropertyInfo(Variant::NIL, get_class_static(), PROPERTY_HINT_NONE, String(), PROPERTY_USAGE_CATEGORY)); if (!_is_gpl_reversed()) { ::ClassDB::get_property_list(#m_class, p_list, true, this); } if (m_class::_get_get_property_list() != m_inherits::_get_get_property_list()) { _get_property_list(p_list); } if (_is_gpl_reversed()) { ::ClassDB::get_property_list(#m_class, p_list, true, this); } if (p_reversed) { m_inherits::_get_property_listv(p_list, p_reversed); } } _FORCE_INLINE_ void (Object::*_get_validate_property() const)(PropertyInfo & p_property) const { return (void(Object::*)(PropertyInfo &) const) & m_class::_validate_property; } virtual void _validate_propertyv(PropertyInfo &p_property) const override { m_inherits::_validate_propertyv(p_property); if (m_class::_get_validate_property() != m_inherits::_get_validate_property()) { _validate_property(p_property); } } _FORCE_INLINE_ bool (Object::*_get_property_can_revert() const)(const StringName &p_name) const { return (bool(Object::*)(const StringName &) const) & m_class::_property_can_revert; } virtual bool _property_can_revertv(const StringName &p_name) const override { if (m_class::_get_property_can_revert() != m_inherits::_get_property_can_revert()) { if (_property_can_revert(p_name)) { return true; } } return m_inherits::_property_can_revertv(p_name); } _FORCE_INLINE_ bool (Object::*_get_property_get_revert() const)(const StringName &p_name, Variant &) const { return (bool(Object::*)(const StringName &, Variant &) const) & m_class::_property_get_revert; } virtual bool _property_get_revertv(const StringName &p_name, Variant &r_ret) const override { if (m_class::_get_property_get_revert() != m_inherits::_get_property_get_revert()) { if (_property_get_revert(p_name, r_ret)) { return true; } } return m_inherits::_property_get_revertv(p_name, r_ret); } _FORCE_INLINE_ void (Object::*_get_notification() const)(int) { return (void(Object::*)(int)) & m_class::_notification; } virtual void _notificationv(int p_notification, bool p_reversed) override { if (!p_reversed) { m_inherits::_notificationv(p_notification, p_reversed); } if (m_class::_get_notification() != m_inherits::_get_notification()) { _notification(p_notification); } if (p_reversed) { m_inherits::_notificationv(p_notification, p_reversed); } } private:
#define GDEXTENSION_CLASS(m_class, m_inherits) private: void operator=(const m_class &p_rval) {} protected: virtual const GDExtensionInstanceBindingCallbacks *_get_bindings_callbacks() const override { return &_gde_binding_callbacks; } m_class(const char *p_godot_class) : m_inherits(p_godot_class) {} m_class(GodotObject *p_godot_object) : m_inherits(p_godot_object) {} static void (*_get_bind_methods())() { return nullptr; } static void (Wrapped::*_get_notification())(int) { return nullptr; } static bool (Wrapped::*_get_set())(const ::godot::StringName &p_name, const Variant &p_property) { return nullptr; } static bool (Wrapped::*_get_get())(const ::godot::StringName &p_name, Variant &r_ret) const { return nullptr; } static void (Wrapped::*_get_get_property_list())(List<PropertyInfo> * p_list) const { return nullptr; } static bool (Wrapped::*_get_property_can_revert())(const ::godot::StringName &p_name) { return nullptr; } static bool (Wrapped::*_get_property_get_revert())(const ::godot::StringName &p_name, Variant &) { return nullptr; } static String (Wrapped::*_get_to_string())() { return nullptr; } public: static void initialize_class() {} static ::godot::StringName &get_class_static() { static ::godot::StringName string_name = ::godot::StringName(#m_class); return string_name; } static ::godot::StringName &get_parent_class_static() { return m_inherits::get_class_static(); } static void *_gde_binding_create_callback(void *p_token, void *p_instance) { return new ("") m_class((GodotObject *)p_instance); } static void _gde_binding_free_callback(void *p_token, void *p_instance, void *p_binding) { reinterpret_cast<m_class *>(p_binding)->~m_class(); Memory::free_static(reinterpret_cast<m_class *>(p_binding)); } static GDExtensionBool _gde_binding_reference_callback(void *p_token, void *p_instance, GDExtensionBool p_reference) { return true; } static constexpr GDExtensionInstanceBindingCallbacks _gde_binding_callbacks = { _gde_binding_create_callback, _gde_binding_free_callback, _gde_binding_reference_callback, }; m_class() : m_class(#m_class) {}
